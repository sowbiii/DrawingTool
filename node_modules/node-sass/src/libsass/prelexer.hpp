#define SASS_PRELEXER

namespace Sass {
  namespace Prelexer {

    typedef int (*ctype_predicate)(int);
    typedef const char* (*prelexer)(const char*);

    // Match a single character literal.
    template <char pre>
    const char* exactly(const char* src) {
      return *src == pre ? src + 1 : 0;
    }

    // Match a string constant.
    template <const char* prefix>
    const char* exactly(const char* src) {
      const char* pre = prefix;
      while (*pre && *src == *pre) ++src, ++pre;
      return *pre ? 0 : src;
    }

    // Match a single character that satifies the supplied ctype predicate.
    template <ctype_predicate pred>
    const char* class_char(const char* src) {
      return pred(*src) ? src + 1 : 0;
    }

    // Match a single character that is a member of the supplied class.
    template <const char* char_class>
    const char* class_char(const char* src) {
      const char* cc = char_class;
      while (*cc && *src != *cc) ++cc;
      return *cc ? src + 1 : 0;
    }

    // Match a sequence of characters that all satisfy the supplied ctype predicate.
    template <ctype_predicate pred>
    const char* class_chars(const char* src) {
      const char* p = src;
      while (pred(*p)) ++p;
      return p == src ? 0 : p;
    }

    // Match a sequence of characters that are all members of the supplied class.
    template <const char* char_class>
    const char* class_chars(const char* src) {
      const char* p = src;
      while (class_char<char_class>(p)) ++p;
      return p == src ? 0 : p;
    }

    // Match a sequence of characters up to the next newline.
    template <const char* prefix>
    const char* to_endl(const char* src) {
      if (!(src = exactly<prefix>(src))) return 0;
      while (*src && *src != 